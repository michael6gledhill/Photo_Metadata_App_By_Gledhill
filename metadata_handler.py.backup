#!/usr/bin/env python3
"""
Metadata handler module for Photo Metadata Editor.
Handles EXIF (via piexif) and XMP (via sidecar files).
Compatible with macOS, Linux, and Windows.
"""

import os
import json
import shutil
import logging
import tempfile
import xml.etree.ElementTree as ET
import re
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, List, Any, Tuple

try:
    import piexif
    HAS_PIEXIF = True
except ImportError:
    HAS_PIEXIF = False

logger = logging.getLogger(__name__)


class MetadataManager:
    """Handles metadata reading/writing using piexif (EXIF) and sidecar XMP."""
    
    def __init__(self):
        """Initialize metadata manager."""
        self.method = "piexif + sidecar XMP"
        logger.info(f"Metadata handling: {self.method}")
    
    def get_metadata(self, file_path: str) -> Dict[str, Any]:
        """
        Extract EXIF and XMP metadata from a file.
        
        Returns:
            dict with 'exif' and 'xmp' keys, each containing tag->value mappings
        """
        metadata = {'exif': {}, 'xmp': {}, 'method': self.method}
        
        try:
            metadata.update(self._get_metadata_python(file_path))
        except Exception as e:
            logger.warning(f"Error reading metadata from {file_path}: {e}")
        
        return metadata

    def _get_metadata_python(self, file_path: str) -> Dict[str, Any]:
        """Extract metadata using piexif and sidecar XMP."""
        exif_data = {}
        xmp_data = {}
        
        # EXIF via piexif
        if HAS_PIEXIF:
            try:
                exif_dict = piexif.load(file_path)
                for ifd in exif_dict:
                    if ifd == "GPS":
                        continue
                    for tag in exif_dict[ifd]:
                        tag_name = piexif.TAGS[ifd][tag]["name"]
                        value = exif_dict[ifd][tag]
                        if isinstance(value, bytes):
                            try:
                                value = value.decode('utf-8', errors='ignore')
                            except:
                                value = str(value)
                        exif_data[tag_name] = value
            except Exception as e:
                logger.debug(f"piexif read error: {e}")
        
        # XMP via sidecar
        sidecar_path = self._xmp_sidecar_path(file_path)
        if sidecar_path.exists():
            try:
                xmp_data.update(self._read_xmp_sidecar(sidecar_path))
            except Exception as e:
                logger.debug(f"sidecar XMP read error: {e}")

        return {'exif': exif_data, 'xmp': xmp_data}
    
    def set_metadata(self, file_path: str, exif_data: Dict = None, xmp_data: Dict = None,
                     merge: bool = False) -> bool:
        """
        Write EXIF and XMP metadata to a file.
        
        Args:
            file_path: Path to image file
            exif_data: Dictionary of EXIF tags to set
            xmp_data: Dictionary of XMP properties to set
            merge: If True, merge with existing; if False, overwrite
        
        Returns:
            True if successful, False otherwise
        """
        if not exif_data and not xmp_data:
            return True
        
        # Use temp file for atomic writes
        temp_fd, temp_path = tempfile.mkstemp(suffix=Path(file_path).suffix)
        try:
            os.close(temp_fd)
            shutil.copy2(file_path, temp_path)
            
            success = self._set_metadata_python(temp_path, exif_data, xmp_data, merge)
            
            if success:
                shutil.move(temp_path, file_path)
                return True
            else:
                os.unlink(temp_path)
                return False
        except Exception as e:
            logger.error(f"Error writing metadata: {e}")
            if os.path.exists(temp_path):
                os.unlink(temp_path)
            return False
    
    def _set_metadata_python(self, file_path: str, exif_data: Dict = None,
                             xmp_data: Dict = None, merge: bool = False) -> bool:
        """Write metadata using piexif and sidecar XMP."""
        try:
            # Write EXIF using piexif
            if HAS_PIEXIF and exif_data:
                try:
                    exif_dict = piexif.load(file_path) if merge else {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}

                    tag_map = {
                        "Artist": ("0th", piexif.ImageIFD.Artist),
                        "Copyright": ("0th", piexif.ImageIFD.Copyright),
                        "ImageDescription": ("0th", piexif.ImageIFD.ImageDescription),
                        "Software": ("0th", piexif.ImageIFD.Software),
                        "DateTime": ("0th", piexif.ImageIFD.DateTime),
                        "DateTimeOriginal": ("Exif", piexif.ExifIFD.DateTimeOriginal),
                        "DateTimeDigitized": ("Exif", piexif.ExifIFD.DateTimeDigitized),
                        "Make": ("0th", piexif.ImageIFD.Make),
                        "Model": ("0th", piexif.ImageIFD.Model),
                        "UserComment": ("Exif", piexif.ExifIFD.UserComment),
                    }

                    for key, value in exif_data.items():
                        if key in tag_map:
                            if isinstance(value, str):
                                value_bytes = value.encode('utf-8', errors='ignore')
                            else:
                                value_bytes = value
                            
                            if key == "UserComment" and isinstance(value_bytes, bytes):
                                prefix = b"ASCII\x00\x00\x00"
                                if value_bytes.startswith(prefix):
                                    value_bytes = value_bytes[len(prefix):]
                                value_bytes = prefix + value_bytes
                            
                            ifd_name, tag_id = tag_map[key]
                            exif_dict[ifd_name][tag_id] = value_bytes

                    piexif.insert(piexif.dump(exif_dict), file_path)
                except Exception as e:
                    logger.warning(f"piexif write error: {e}")
            
            # Write XMP sidecar
            if xmp_data:
                try:
                    sidecar = self._xmp_sidecar_path(file_path)
                    self._write_xmp_sidecar(sidecar, xmp_data)
                    logger.info(f"Wrote XMP sidecar: {sidecar.name}")
                except Exception as e:
                    logger.warning(f"XMP sidecar write error: {e}")
            
            return True
        except Exception as e:
            logger.error(f"Metadata write error: {e}")
            return False
    
    def delete_metadata(self, file_path: str) -> bool:
        """Remove all EXIF and XMP metadata from a file."""
        temp_fd, temp_path = tempfile.mkstemp(suffix=Path(file_path).suffix)
        try:
            os.close(temp_fd)
            shutil.copy2(file_path, temp_path)
            
            success = False
            if HAS_PIEXIF:
                try:
                    piexif.insert(piexif.dump({"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}), temp_path)
                    success = True
                except Exception as e:
                    logger.warning(f"piexif delete error: {e}")
            
            if success:
                shutil.move(temp_path, file_path)
                sidecar = self._xmp_sidecar_path(file_path)
                if sidecar.exists():
                    sidecar.unlink()
                return True
            else:
                if os.path.exists(temp_path):
                    os.unlink(temp_path)
                return False
        except Exception as e:
            logger.error(f"Error deleting metadata: {e}")
            if os.path.exists(temp_path):
                os.unlink(temp_path)
            return False

    @staticmethod
    def _xmp_sidecar_path(file_path: str) -> Path:
        """Return the sidecar .xmp path for a given image file."""
        p = Path(file_path)
        return p.with_suffix(p.suffix + '.xmp')

    def _write_xmp_sidecar(self, sidecar_path: Path, xmp_data: Dict[str, Any]):
        """Write a minimal XMP sidecar (RDF) with common fields."""
        ns = {
            'x': 'adobe:ns:meta/',
            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
            'dc': 'http://purl.org/dc/elements/1.1/',
            'photoshop': 'http://ns.adobe.com/photoshop/1.0/',
            'xmp': 'http://ns.adobe.com/xap/1.0/',
        }

        ET.register_namespace('x', ns['x'])
        ET.register_namespace('rdf', ns['rdf'])
        ET.register_namespace('dc', ns['dc'])
        ET.register_namespace('photoshop', ns['photoshop'])
        ET.register_namespace('xmp', ns['xmp'])

        xmpmeta = ET.Element(ET.QName(ns['x'], 'xmpmeta'))
        rdf = ET.SubElement(xmpmeta, ET.QName(ns['rdf'], 'RDF'))
        desc = ET.SubElement(rdf, ET.QName(ns['rdf'], 'Description'))

        def set_lang_alt(parent, text):
            alt = ET.SubElement(parent, ET.QName(ns['rdf'], 'Alt'))
            li = ET.SubElement(alt, ET.QName(ns['rdf'], 'li'))
            li.set('{http://www.w3.org/XML/1998/namespace}lang', 'x-default')
            li.text = text

        def set_bag(parent, items):
            bag = ET.SubElement(parent, ET.QName(ns['rdf'], 'Bag'))
            for it in items:
                li = ET.SubElement(bag, ET.QName(ns['rdf'], 'li'))
                li.text = it

        norm = {}
        for k, v in xmp_data.items():
            prefix, prop = self._normalize_xmp_key(k)
            if prop:
                norm[(prefix, prop)] = v

        if ('dc', 'creator') in norm:
            creators = norm[('dc', 'creator')]
            vals = [str(x) for x in creators] if isinstance(creators, (list, tuple)) else [str(creators)]
            el = ET.SubElement(desc, ET.QName(ns['dc'], 'creator'))
            set_bag(el, vals)

        if ('dc', 'subject') in norm:
            subs = norm[('dc', 'subject')]
            if isinstance(subs, (list, tuple)):
                vals = [str(x) for x in subs]
            else:
                vals = [s.strip() for s in str(subs).split(',') if s.strip()]
            el = ET.SubElement(desc, ET.QName(ns['dc'], 'subject'))
            set_bag(el, vals)

        if ('dc', 'description') in norm:
            el = ET.SubElement(desc, ET.QName(ns['dc'], 'description'))
            set_lang_alt(el, str(norm[('dc', 'description')]))

        if ('dc', 'title') in norm:
            el = ET.SubElement(desc, ET.QName(ns['dc'], 'title'))
            set_lang_alt(el, str(norm[('dc', 'title')]))

        if ('photoshop', 'Headline') in norm:
            el = ET.SubElement(desc, ET.QName(ns['photoshop'], 'Headline'))
            el.text = str(norm[('photoshop', 'Headline')])

        if ('xmp', 'Rating') in norm:
            el = ET.SubElement(desc, ET.QName(ns['xmp'], 'Rating'))
            el.text = str(norm[('xmp', 'Rating')])

        tree = ET.ElementTree(xmpmeta)
        sidecar_path.parent.mkdir(parents=True, exist_ok=True)
        tree.write(sidecar_path, encoding='utf-8', xml_declaration=True)

    def _read_xmp_sidecar(self, sidecar_path: Path) -> Dict[str, Any]:
        """Read a minimal set of XMP fields from a sidecar."""
        ns = {
            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
            'dc': 'http://purl.org/dc/elements/1.1/',
            'photoshop': 'http://ns.adobe.com/photoshop/1.0/',
            'xmp': 'http://ns.adobe.com/xap/1.0/',
        }
        tree = ET.parse(sidecar_path)
        root = tree.getroot()
        data = {}

        desc = root.find('.//rdf:Description', ns)
        if desc is None:
            return data

        creators = [li.text or '' for li in desc.findall('dc:creator/rdf:Bag/rdf:li', ns)]
        if creators:
            data['dc:creator'] = creators

        subjects = [li.text or '' for li in desc.findall('dc:subject/rdf:Bag/rdf:li', ns)]
        if subjects:
            data['dc:subject'] = subjects

        ddesc = desc.find('dc:description/rdf:Alt/rdf:li', ns)
        if ddesc is not None and ddesc.text:
            data['dc:description'] = ddesc.text

        dtitle = desc.find('dc:title/rdf:Alt/rdf:li', ns)
        if dtitle is not None and dtitle.text:
            data['dc:title'] = dtitle.text

        head = desc.find('photoshop:Headline', ns)
        if head is not None and head.text:
            data['photoshop:Headline'] = head.text

        rating = desc.find('xmp:Rating', ns)
        if rating is not None and rating.text:
            data['xmp:Rating'] = rating.text

        return data

    @staticmethod
    def _normalize_xmp_key(key: str) -> Tuple[str, str]:
        """Normalize XMP keys to (prefix, prop) tuples."""
        if not key:
            return ("xmp", "")

        k = key.strip()
        if k.lower().startswith('xmp-'):
            k = k[4:]

        k_lower = k.lower()

        aliases = {
            'keywords': 'dc:subject',
            'dc:keywords': 'dc:subject',
            'subject': 'dc:subject',
            'creator': 'dc:creator',
            'description': 'dc:description',
            'title': 'dc:title',
            'headline': 'photoshop:Headline',
            'rating': 'xmp:Rating',
        }

        if k_lower in aliases:
            k = aliases[k_lower]

        if ':' in k:
            prefix, prop = k.split(':', 1)
        else:
            prefix, prop = 'dc', k

        return prefix, prop


class TemplateManager:
    """Manages template storage and retrieval."""
    
    def __init__(self):
        """Initialize template manager."""
        self.template_dir = Path.home() / '.photo_meta_editor' / 'templates'
        self.naming_dir = Path.home() / '.photo_meta_editor' / 'naming'
        
        self.template_dir.mkdir(parents=True, exist_ok=True)
        self.naming_dir.mkdir(parents=True, exist_ok=True)
        
        self._create_default_templates()
    
    def _create_default_templates(self):
        """Create default templates and naming conventions if they don't exist."""
        portrait = {
            "name": "Portrait Template",
            "exif": {
                "Artist": "Photographer Name",
                "Copyright": "Â© 2025 Photographer Name",
                "ImageDescription": "Professional portrait photography"
            },
            "xmp": {
                "dc:creator": "Photographer Name",
                "dc:description": "Professional portrait",
                "photoshop:Headline": "Portrait Session"
            }
        }
        
        travel = {
            "name": "Travel Log",
            "exif": {
                "Artist": "Travel Photographer",
                "ImageDescription": "Travel documentation"
            },
            "xmp": {
                "dc:creator": "Travel Photographer",
                "dc:keywords": ["travel", "adventure", "documentation"]
            }
        }
        
        self._save_template_if_not_exists("portrait_template.json", portrait)
        self._save_template_if_not_exists("travel_template.json", travel)
        
        naming1 = {
            "name": "Date + Title",
            "pattern": "{date}_{title}_{sequence:03d}"
        }
        
        naming2 = {
            "name": "Timestamp + Camera",
            "pattern": "{datetime:%Y%m%d_%H%M%S}_{camera_model}"
        }
        
        self._save_naming_if_not_exists("date_title.json", naming1)
        self._save_naming_if_not_exists("timestamp_camera.json", naming2)
    
    def _save_template_if_not_exists(self, filename: str, template: Dict):
        """Save template if it doesn't already exist."""
        path = self.template_dir / filename
        if not path.exists():
            with open(path, 'w') as f:
                json.dump(template, f, indent=2)
    
    def _save_naming_if_not_exists(self, filename: str, naming: Dict):
        """Save naming convention if it doesn't already exist."""
        path = self.naming_dir / filename
        if not path.exists():
            with open(path, 'w') as f:
                json.dump(naming, f, indent=2)
    
    def get_templates(self) -> Dict[str, Dict]:
        """Get all saved templates."""
        templates = {}
        try:
            for file in self.template_dir.glob('*.json'):
                try:
                    with open(file, 'r') as f:
                        data = json.load(f)
                        templates[data.get('name', file.stem)] = self._normalize_template_data(data)
                except Exception as e:
                    logger.warning(f"Error loading template {file}: {e}")
        except Exception as e:
            logger.error(f"Error reading templates: {e}")
        
        return templates
    
    def get_naming_conventions(self) -> Dict[str, Dict]:
        """Get all saved naming conventions."""
        conventions = {}
        try:
            for file in self.naming_dir.glob('*.json'):
                try:
                    with open(file, 'r') as f:
                        data = json.load(f)
                        conventions[data.get('name', file.stem)] = data
                except Exception as e:
                    logger.warning(f"Error loading naming convention {file}: {e}")
        except Exception as e:
            logger.error(f"Error reading naming conventions: {e}")
        
        return conventions
    
    def save_template(self, name: str, exif: Dict, xmp: Dict) -> bool:
        """Save a new template."""
        try:
            template = {
                "name": name,
                "exif": exif,
                "xmp": xmp
            }
            
            filename = name.lower().replace(' ', '_') + '.json'
            path = self.template_dir / filename
            
            with open(path, 'w') as f:
                json.dump(template, f, indent=2)
            
            logger.info(f"Template saved: {name}")
            return True
        except Exception as e:
            logger.error(f"Error saving template: {e}")
            return False
    
    def save_naming(self, name: str, pattern: str) -> bool:
        """Save a new naming convention."""
        try:
            naming = {
                "name": name,
                "pattern": pattern
            }
            
            filename = name.lower().replace(' ', '_') + '.json'
            path = self.naming_dir / filename
            
            with open(path, 'w') as f:
                json.dump(naming, f, indent=2)
            
            logger.info(f"Naming convention saved: {name}")
            return True
        except Exception as e:
            logger.error(f"Error saving naming convention: {e}")
            return False
    
    def delete_template(self, name: str) -> bool:
        """Delete a template."""
        try:
            for file in self.template_dir.glob('*.json'):
                with open(file, 'r') as f:
                    data = json.load(f)
                    if data.get('name') == name:
                        file.unlink()
                        return True
        except Exception as e:
            logger.error(f"Error deleting template: {e}")
        
        return False
    
    def delete_naming(self, name: str) -> bool:
        """Delete a naming convention."""
        try:
            for file in self.naming_dir.glob('*.json'):
                with open(file, 'r') as f:
                    data = json.load(f)
                    if data.get('name') == name:
                        file.unlink()
                        return True
        except Exception as e:
            logger.error(f"Error deleting naming convention: {e}")
        
        return False
    
    def import_template(self, data: Dict) -> Tuple[bool, str]:
        """Import a template from JSON data."""
        try:
            if 'name' not in data:
                return False, "Template must have a 'name' field"
            
            normalized = self._normalize_template_data(data)
            name = normalized['name']
            exif = normalized.get('exif', {})
            xmp = normalized.get('xmp', {})
            
            if self.save_template(name, exif, xmp):
                return True, f"Template '{name}' imported successfully"
            else:
                return False, "Failed to save template"
                
        except Exception as e:
            return False, f"Import error: {str(e)}"
    
    def import_naming(self, data: Dict) -> Tuple[bool, str]:
        """Import a naming convention from JSON data."""
        try:
            if 'name' not in data:
                return False, "Naming convention must have a 'name' field"
            if 'pattern' not in data:
                return False, "Naming convention must have a 'pattern' field"
            
            name = data['name']
            pattern = data['pattern']
            
            if self.save_naming(name, pattern):
                return True, f"Naming convention '{name}' imported successfully"
            else:
                return False, "Failed to save naming convention"
                
        except Exception as e:
            return False, f"Import error: {str(e)}"
    
    @staticmethod
    def _normalize_template_data(data: Dict) -> Dict:
        """Normalize template dict to ensure 'exif'/'xmp' keys exist (case-insensitive)."""
        exif = data.get('exif') or data.get('EXIF') or {}
        xmp = data.get('xmp') or data.get('XMP') or {}
        name = data.get('name') or data.get('Name') or ''
        data['exif'] = exif
        data['xmp'] = xmp
        data['name'] = name
        return data


class NamingEngine:
    """Handles filename token replacement."""
    
    @staticmethod
    def generate_filename(pattern: str, file_path: str, metadata: Dict, sequence: int = 1) -> str:
        """
        Generate a new filename from a pattern and metadata.
        
        Args:
            pattern: Naming pattern with tokens like {date}, {title}, etc.
            file_path: Original file path
            metadata: Metadata dict with 'exif' and 'xmp' keys
            sequence: Sequence number for {sequence:Nd} tokens
        
        Returns:
            New filename with extension preserved
        """
        original_path = Path(file_path)
        extension = original_path.suffix
        original_name = original_path.stem
        
        exif = metadata.get('exif', {})
        xmp = metadata.get('xmp', {})
        
        title = exif.get('ImageDescription', xmp.get('dc:description', ''))
        date_str = exif.get('DateTime', datetime.now().strftime('%Y-%m-%d'))
        camera_model = exif.get('Model', 'unknown')
        
        try:
            if isinstance(date_str, str) and ':' in date_str:
                date_obj = datetime.strptime(date_str, '%Y:%m:%d %H:%M:%S')
            else:
                date_obj = datetime.now()
        except:
            date_obj = datetime.now()
        
        result = pattern
        result = result.replace('{title}', str(title)[:50])
        result = result.replace('{date}', date_obj.strftime('%Y-%m-%d'))
        result = result.replace('{camera_model}', str(camera_model)[:30])
        result = result.replace('{original_name}', original_name)
        result = result.replace('{userid}', os.getenv('USER', 'user'))
        
        datetime_match = re.search(r'\{datetime:([^}]+)\}', result)
        if datetime_match:
            fmt = datetime_match.group(1)
            try:
                result = result.replace(datetime_match.group(0), date_obj.strftime(fmt))
            except:
                pass
        
        sequence_match = re.search(r'\{sequence:(\d+)d\}', result)
        if sequence_match:
            padding = int(sequence_match.group(1))
            result = result.replace(sequence_match.group(0), str(sequence).zfill(padding))
        
        return result + extension
